	 

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Fixed versus Floating Point</title>
<link href="../new/css/default.css" rel="stylesheet" type="text/css" />

<script type='text/javascript' src='../new/js/jquery-1.5.js'></script>
<script type='text/javascript' src='../new/js/jquery.droppy.js'></script>
<link rel="stylesheet" href="../new/css/droppy.css" type="text/css" />
<script type='text/javascript' src='../new/js/jcc.js'></script>
<script>
$(function(){
	if($.browser.msie){
        if($.browser.version.substr(0,1)!="9"){
            $('#greenBox2').corner({tl:{radius:5}, tr:{radius:5}, bl:{radius:5}, br:{radius:5}, antiAlias:true });
        }
    }else{
        $('#greenBox2').corner({tl:{radius:5}, tr:{radius:5}, bl:{radius:3}, br:{radius:5}, antiAlias:true });
    }
});
</script>

<link rel="stylesheet" href="../new/css/jquery.treeview.css" />
<script src="../new/js/jquery.cookie.js" type="text/javascript"></script>
<script src="../new/js/jquery.treeview.js" type="text/javascript"></script>
<script type="text/javascript" src="../new/js/demo.js"></script>

</head>

<body>


<div id="divPage">
	<div id="wrapper" class="not-logged-in">
		
		<!-- Header -->
		
<div id="header">
			<h1>The Scientist and Engineer's Guide to<br />Digital Signal Processing<br /><span class="txtBlue txt26">By Steven W. Smith, Ph.D.</span></h1>
			<div id="menu">
				<ul id='nav' style="margin-left:10px;"><li><a href="../index.html">Home</a></li><li><a href="../pdfbook.htm" class="selected">The Book by Chapters</a></li><li class="drop"><a href="../about.htm">About the Book</a>					
					<ul>						
						<li><a href="../copyrite.htm">Copyright and permissible use</a></li>							
						<li><a href="../whatdsp.htm">What is DSP?</a></li>
						<li><a href="../eightres.htm">8 good reasons for learning DSP</a></li>
						<li><a href="../reviews.htm">Comments by reviewers</a></li>
						<li><a href="../errata.htm">Errata</a></li>			
						<li><a href="http://www.dspguide.com/ch28/download.htm">Free Software and Teaching Aids</a></li>						
						<li><a href="../editions.htm">Differences Between Editions</a></li>
					</ul>
				  </li><li><a href="../swsmith.htm">Steven W. Smith</a></li><li><a href="http://www.dsprelated.com/blogs-1/nf/Steve_Smith.php">Blog</a></li><li><a href="../contact.htm">Contact</a></li>					
				</ul>
				<script type="text/javascript">$(function() {$("#nav").droppy();});</script>
			</div>
		</div>

		
		<!-- Content -->
		
		<!-- -->		
		<div id="columnLeft">			
			
			<div class="box">
				<h2>Book Search</h2>
				<div id="search">
					<form action="http://www.dspguide.com/search.php" method="post">
						<input type="text" name="searchfor" class="txtField" />
						<input type="image" src="../new/images/btn-go.png" name="Submit" value="Submit" class="button" />
						<div class="clear"><!-- --></div>
					</form>
				</div>
			</div>
		
			
			<div class="box">
				<h2>Download this chapter in PDF format</h2>
				<b><a href="../CH28.PDF">Chapter28.pdf</a></b>
				<br />
				<img src="../new/images/adobe-reader.png" alt="" vspace="5" />
			</div>

			<div class="box">
				<h2>Table of contents</h2>
				<ul id="red" class="treeview-red">	 
					<ul style="border-top:1px solid #aeaeeb;"><li style="border-top:1px solid #aeaeeb;"><a href="../ch1.htm">1: The Breadth and Depth of DSP</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/1.htm">The Roots of DSP</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/2.htm">Telecommunications</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/3.htm">Audio Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/4.htm" style="color:#b4b4e9;">Echo Location</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/5.htm">Image Processing</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2.htm">2: Statistics, Probability and Noise</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/1.htm">Signal and Graph Terminology</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/2.htm">Mean and Standard Deviation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/3.htm">Signal vs. Underlying Process</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/4.htm" style="color:#b4b4e9;">The Histogram, Pmf and Pdf</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/5.htm">The Normal Distribution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/6.htm">Digital Noise Generation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/7.htm">Precision and Accuracy</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3.htm">3: ADC and DAC</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/1.htm">Quantization</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/2.htm">The Sampling Theorem</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/3.htm">Digital-to-Analog Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/4.htm" style="color:#b4b4e9;">Analog Filters for Data Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/5.htm">Selecting The Antialias Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/6.htm">Multirate Data Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/7.htm">Single Bit Data Conversion</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4.htm">4: DSP Software</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/1.htm">Computer Numbers</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/2.htm">Fixed Point (Integers)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/3.htm">Floating Point (Real Numbers)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/4.htm" style="color:#b4b4e9;">Number Precision</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/5.htm">Execution Speed: Program Language</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/6.htm">Execution Speed: Hardware</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/7.htm">Execution Speed: Programming Tips</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5.htm">5: Linear Systems</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/1.htm">Signals and Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/2.htm">Requirements for Linearity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/3.htm">Static Linearity and Sinusoidal Fidelity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/4.htm" style="color:#b4b4e9;">Examples of Linear and Nonlinear Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/5.htm">Special Properties of Linearity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/6.htm">Superposition: the Foundation of DSP</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/7.htm">Common Decompositions</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/8.htm">Alternatives to Linearity</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6.htm">6: Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/1.htm">The Delta Function and Impulse Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/2.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/3.htm">The Input Side Algorithm</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/4.htm" style="color:#b4b4e9;">The Output Side Algorithm</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/5.htm">The Sum of Weighted Inputs</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7.htm">7: Properties of Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/1.htm">Common Impulse Responses</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/2.htm">Mathematical Properties</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/3.htm">Correlation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/4.htm" style="color:#b4b4e9;">Speed</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8.htm">8: The Discrete Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/1.htm">The Family of Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/2.htm">Notation and Format of the Real DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/3.htm">The Frequency Domain's Independent Variable</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/4.htm" style="color:#b4b4e9;">DFT Basis Functions</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/5.htm">Synthesis, Calculating the Inverse DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/6.htm">Analysis, Calculating the DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/7.htm">Duality</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/8.htm">Polar Notation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/9.htm">Polar Nuisances</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9.htm">9: Applications of the DFT</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/1.htm">Spectral Analysis of Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/2.htm">Frequency Response of Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/3.htm">Convolution via the Frequency Domain</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10.htm">10: Fourier Transform Properties</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/1.htm">Linearity of the Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/2.htm">Characteristics of the Phase</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/3.htm">Periodic Nature of the DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/4.htm" style="color:#b4b4e9;">Compression and Expansion, Multirate methods</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/5.htm">Multiplying Signals (Amplitude Modulation)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/6.htm">The Discrete Time Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/7.htm">Parseval's Relation</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11.htm">11: Fourier Transform Pairs</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/1.htm">Delta Function Pairs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/2.htm">The Sinc Function</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/3.htm">Other Transform Pairs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/4.htm" style="color:#b4b4e9;">Gibbs Effect</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/5.htm">Harmonics</a></li><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch11/6.htm">Chirp Signals</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12.htm">12: The Fast Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/1.htm">Real DFT Using the Complex DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/2.htm">How the FFT works</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/3.htm">FFT Programs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/4.htm" style="color:#b4b4e9;">Speed and Precision Comparisons</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/5.htm">Further Speed Increases</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13.htm">13: Continuous Signal Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/1.htm">The Delta Function</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/2.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/3.htm">The Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/4.htm" style="color:#b4b4e9;">The Fourier Series</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14.htm">14: Introduction to Digital Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/1.htm">Filter Basics</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/2.htm">How Information is Represented in Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/3.htm">Time Domain Parameters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/4.htm" style="color:#b4b4e9;">Frequency Domain Parameters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/5.htm">High-Pass, Band-Pass and Band-Reject Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/6.htm">Filter Classification</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15.htm">15: Moving Average Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/1.htm">Implementation by Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/2.htm">Noise Reduction vs. Step Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/3.htm">Frequency Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/4.htm" style="color:#b4b4e9;">Relatives of the Moving Average Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/5.htm">Recursive Implementation</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16.htm">16: Windowed-Sinc Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/1.htm">Strategy of the Windowed-Sinc</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/2.htm">Designing the Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/3.htm">Examples of Windowed-Sinc Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/4.htm" style="color:#b4b4e9;">Pushing it to the Limit</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17.htm">17: Custom Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/1.htm">Arbitrary Frequency Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/2.htm">Deconvolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/3.htm">Optimal Filters</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18.htm">18: FFT Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/1.htm">The Overlap-Add Method</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/2.htm">FFT Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/3.htm">Speed Improvements</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19.htm">19: Recursive Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/1.htm">The Recursive Method</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/2.htm">Single Pole Recursive Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/3.htm">Narrow-band Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/4.htm" style="color:#b4b4e9;">Phase Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/5.htm">Using Integers</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20.htm">20: Chebyshev Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/1.htm">The Chebyshev and Butterworth Responses</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/2.htm">Designing the Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/3.htm">Step Response Overshoot</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/4.htm" style="color:#b4b4e9;">Stability</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21.htm">21: Filter Comparison</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/1.htm">Match #1: Analog vs. Digital Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/2.htm">Match #2: Windowed-Sinc vs. Chebyshev</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/3.htm">Match #3: Moving Average vs. Single Pole</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22.htm">22: Audio Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/1.htm">Human Hearing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/2.htm">Timbre</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/3.htm">Sound Quality vs. Data Rate</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/4.htm" style="color:#b4b4e9;">High Fidelity Audio</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/5.htm">Companding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/6.htm">Speech Synthesis and Recognition</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/7.htm">Nonlinear Audio Processing</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23.htm">23: Image Formation & Display</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/1.htm">Digital Image Structure</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/2.htm">Cameras and Eyes</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/3.htm">Television Video Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/4.htm" style="color:#b4b4e9;">Other Image Acquisition and Display</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/5.htm">Brightness and Contrast Adjustments</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/6.htm">Grayscale Transforms</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/7.htm">Warping</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24.htm">24: Linear Image Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/1.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/2.htm">3x3 Edge Modification</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/3.htm">Convolution by Separability</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/4.htm" style="color:#b4b4e9;">Example of a Large PSF: Illumination Flattening</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/5.htm">Fourier Image Analysis</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/6.htm">FFT Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/7.htm">A Closer Look at Image Convolution</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25.htm">25: Special Imaging Techniques</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/1.htm">Spatial Resolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/2.htm">Sample Spacing and Sampling Aperture</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/3.htm">Signal-to-Noise Ratio</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/4.htm" style="color:#b4b4e9;">Morphological Image Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/5.htm">Computed Tomography</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26.htm">26: Neural Networks (and more!)</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/1.htm">Target Detection</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/2.htm">Neural Network Architecture</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/3.htm">Why Does it Work?</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/4.htm" style="color:#b4b4e9;">Training the Neural Network</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/5.htm">Evaluating the Results</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/6.htm">Recursive Filter Design</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27.htm">27: Data Compression</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/1.htm">Data Compression Strategies</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/2.htm">Run-Length Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/3.htm">Huffman Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/4.htm" style="color:#b4b4e9;">Delta Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/5.htm">LZW Compression</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/6.htm">JPEG (Transform Compression)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/7.htm">MPEG</a></li></ul></li><li class="open" style="border-top:1px solid #aeaeeb;"><a href="../ch28.htm" style="color:#b4b4e9;">28: Digital Signal Processors</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="1.htm">How DSPs are Different from Other Microprocessors</a></li><li style="border-top:1px solid #aeaeeb;"><a href="2.htm">Circular Buffering</a></li><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch28/3.htm">Architecture of the Digital Signal Processor</a></li><li style="border-top:1px solid #aeaeeb;"><a href="4.htm" style="color:#b4b4e9;">Fixed versus Floating Point</a></li><li style="border-top:1px solid #aeaeeb;"><a href="5.htm">C versus Assembly</a></li><li style="border-top:1px solid #aeaeeb;"><a href="6.htm">How Fast are DSPs?</a></li><li style="border-top:1px solid #aeaeeb;"><a href="7.htm">The Digital Signal Processor Market</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29.htm">29: Getting Started with DSPs</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch29/1.htm">The ADSP-2106x family</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/2.htm">The SHARC EZ-KIT Lite</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/3.htm">Design Example: An FIR Audio Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/4.htm" style="color:#b4b4e9;">Analog Measurements on a DSP System</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/5.htm">Another Look at Fixed versus Floating Point</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/6.htm">Advanced Software Tools</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30.htm">30: Complex Numbers</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/1.htm">The Complex Number System</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/2.htm">Polar Notation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/3.htm">Using Complex Numbers by Substitution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/4.htm" style="color:#b4b4e9;">Complex Representation of Sinusoids</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/5.htm">Complex Representation of Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/6.htm">Electrical Circuit Analysis</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31.htm">31: The Complex Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/1.htm">The Real DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/2.htm">Mathematical Equivalence</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/3.htm">The Complex DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/4.htm" style="color:#b4b4e9;">The Family of Fourier Transforms</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/5.htm">Why the Complex Fourier Transform is Used</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32.htm">32: The Laplace Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/1.htm">The Nature of the s-Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/2.htm">Strategy of the Laplace Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/3.htm">Analysis of Electric Circuits</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/4.htm" style="color:#b4b4e9;">The Importance of Poles and Zeros</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/5.htm">Filter Design in the s-Domain</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33.htm">33: The z-Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/1.htm">The Nature of the z-Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/2.htm">Analysis of Recursive Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/3.htm">Cascade and Parallel Stages</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/4.htm" style="color:#b4b4e9;">Spectral Inversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/5.htm">Gain Changes</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/6.htm">Chebyshev-Butterworth Filter Design</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/7.htm">The Best and Worst of DSP</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34.htm">34: Explaining Benford's Law</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/1.htm">Frank Benford's Discovery</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/2.htm">Homomorphic Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/3.htm">The Ones Scaling Test</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/4.htm" style="color:#b4b4e9;">Writing Benford's Law as a Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/5.htm">Solving in the Frequency Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/6.htm">Solving Mystery #1</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/7.htm">Solving Mystery #2</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/8.htm">More on Following Benford's law</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/9.htm">Analysis of the Log-Normal Distribution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/10.htm">The Power of Signal Processing</a></li></ul></li>
					</ul>
				</ul>			
			</div>

			<div class="box">
				<h2>How to order your own hardcover copy</h2>
				Wouldn't you rather have a bound book instead of 640 loose pages?<br />
				Your laser printer will thank you!<br />
				<b>Order from <a href="http://www.amazon.com/Scientist-Engineers-Digital-Signal-Processing/dp/0966017633/ref=pd_bxgy_b_img_a">Amazon.com</a>.</b>
			</div>

		
			
		</div>	

		<!-- -->		
		<div id="columnRight">	
		
			<div id="adbox">
				
			
			</div>	 
			
<div class="breadcrumbs"><a href="../ch28.htm">Chapter 28 - Digital Signal Processors</a> / Fixed versus Floating Point</div><h2>Chapter 28: Digital Signal Processors</h2><div class="subTitle">Fixed versus Floating Point</div><p><div style="text-align: justify"><p>Digital Signal Processing can be divided into two categories, <span style="font-weight: bold">fixed point</span>
and <span style="font-weight: bold">floating point</span>.  These refer to the format used to store and
manipulate numbers within the devices.  Fixed point DSPs usually
represent each number with a minimum of 16 bits, although a different
length can be used.  For instance, Motorola manufactures a family of
fixed point DSPs that use 24 bits.  There are four common ways that
these 2<sup>16</sup> = 65536 possible bit patterns can represent a number.   In
<span style="font-weight: bold">unsigned integer</span>, the stored number can take on any integer value from
0 to 65,535.  Similarly, <span style="font-weight: bold">signed integer</span> uses two's complement to make
the range include negative numbers, from -32,768 to 32,767.  With
<span style="font-weight: bold">unsigned fraction</span> notation, the 65,536 levels are spread uniformly
between 0 and 1.  Lastly, the <span style="font-weight: bold">signed fraction</span> format allows negative
numbers, equally spaced between -1 and 1. </p>

<p>In comparison, floating point DSPs typically use a minimum of 32 bits
to store each value.  This results in many more bit patterns than for
fixed point, 2<sup>32</sup> = 4,294,967,296 to be exact.  A key feature of floating
point notation is that the represented numbers are <i>not</i> uniformly spaced. 
 In the most common format (ANSI/IEEE Std. 754-1985), the largest
and smallest numbers are &plusmn;3.4&times;10<sup>38</sup> and ±1.2×10<sup>-38</sup>, respectively.  The
represented values are unequally spaced between these two extremes,
such that the gap between any two numbers is about ten-million times
smaller than the value of the numbers.   This is important because it
places large gaps between large numbers, but small gaps between small
numbers.  Floating point notation is discussed in more detail in Chapter
4.  </p>

<p>All floating point DSPs can also handle fixed point numbers, a necessity
to implement counters, loops, and signals coming from the ADC and
going to the DAC.  However, this doesn't mean that fixed point math
will be carried out as quickly as the floating point operations; it depends
on the internal architecture.  For instance, the SHARC DSPs are
optimized for both floating point and fixed point operations, and
executes them with equal efficiency.  For this reason, the SHARC
devices are often referred to as "32-bit DSPs," rather than just "Floating
Point."</p>

<p>Figure 28-6 illustrates the primary trade-offs between fixed and floating
point DSPs.  In Chapter 3 we stressed that fixed point arithmetic is
much</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/F_28_6.gif" border="0" alt=""></img></div>

<p>faster than floating point in general purpose computers.  However, with
DSPs the speed is about the same, a result of the hardware being highly
optimized for math operations.  The internal architecture of a floating
point DSP is more complicated than for a fixed point device.  All the
registers and data buses must be 32 bits wide instead of only 16; the
multiplier and ALU must be able to quickly perform floating point
arithmetic, the instruction set must be larger (so that they can handle
both floating and fixed point numbers), and so on.  Floating point (32
bit) has better precision and a higher dynamic range than fixed point (16
bit) .  In addition, floating point programs often have a shorter
development cycle, since the programmer doesn't generally need to
worry about issues such as overflow, underflow, and round-off error. </p>

<p>On the other hand, fixed point DSPs have traditionally been cheaper
than floating point devices.  Nothing changes more rapidly than the
price of electronics; anything you find in a book will be out-of-date
before it is printed.  Nevertheless, cost is a key factor in understanding
how DSPs are evolving, and we need to give you a general idea.  When
this book was completed in 1999, fixed point DSPs sold for between $5
and $100, while floating point devices were in the range of $10 to $300. 
This difference in cost can be viewed as a measure of the relative
complexity between the devices.  If you want to find out what the prices
are <i>today</i>, you need to look <i>today</i>. </p>

<p>Now let's turn our attention to <i>performance</i>; what can a 32-bit floating
point system do that a 16-bit fixed point can't?  The answer to this
question is <span style="font-weight: bold">signal-to-noise ratio</span>.   Suppose we store a number in a 32 bit
floating point format.  As previously mentioned, the gap between this
number and its adjacent neighbor is about one ten-millionth of the value
of the number.  To store the number, it must be round up or down by a
maximum of one-half the gap size.  In other words, each time we store
a number in floating point notation, we add <i>noise</i> to the signal. </p>

<p>The same thing happens when a number is stored as a 16-bit fixed point
value, except that the added noise is much worse.   This is because the
gaps between adjacent numbers are much larger.  For instance, suppose
we store  the number 10,000 as a signed integer (running from -32,768
to 32,767). The gap between numbers is one ten-thousandth of the value
of the number we are storing.  If we want to store the number 1000, the
gap between numbers is only one one-thousandth of the value.</p>

<p>Noise in signals is usually represented by its <i>standard deviation</i>.  This
was discussed in detail in Chapter 2.  For here, the important fact is that
the standard deviation of this <span style="font-weight: bold">quantization noise</span> is about one-third of the
gap size.  This means that the signal-to-noise ratio for storing a floating
point number is about 30 million to one, while for a fixed point number
it is only about ten-thousand to one.  In other words, floating point has
roughly 30,000 times less quantization noise than fixed point. </p>

<p>This brings up an important way that DSPs are different from traditional
microprocessors.  Suppose we implement an FIR filter in fixed point. 
To do this, we loop through each coefficient, multiply it by the
appropriate sample from the input signal, and add the product to an
accumulator.  Here's the problem.  In traditional microprocessors, this
accumulator is just another 16 bit fixed point variable.  To avoid
overflow, we need to scale the values being added, and will
correspondingly add quantization noise on each step.  In the worst case,
this quantization noise will simply add, greatly lowering the signal-to-noise ratio of the system.  For instance, in a 500 coefficient FIR filter,
the noise on each output sample may be 500 times the noise on each
input sample.  The signal-to-noise ratio of <i>ten-thousand to one</i> has
dropped to a ghastly <i>twenty to one.</i>  Although this is an extreme case, it
illustrates the main point: when many operations are carried out on each
sample, it's bad, really bad.  See Chapter 3 for more details.</p>

<p>DSPs handle this problem by using an <span style="font-weight: bold">extended precision accumulator</span>. 
This is a special register that has 2-3 times as many bits as the other
memory locations.  For example, in a 16 bit DSP it may have 32 to 40
bits, while in the SHARC DSPs it contains 80 bits for fixed point use. 
This extended range virtually eliminates round-off noise while the
accumulation is in progress.  The only round-off error suffered is when
the accumulator is scaled and stored in the 16 bit memory.  This strategy
works very well, although it does limit how some algorithms must be
carried out.  In comparison, floating point has such low quantization
noise that these techniques are usually not necessary. </p>

<p>In addition to having lower quantization noise, floating point systems
are also easier to develop algorithms for.  Most DSP techniques are
based on repeated multiplications and additions.  In fixed point, the
possibility of an overflow or underflow needs to be considered after
each operation.  The programmer needs to continually understand the
amplitude of the numbers, how the quantization errors are accumulating,
and what scaling needs to take place.  In comparison, these issues do not
arise in floating point; the numbers take care of themselves (except in
rare cases).  </p>

<p>To give you a better understanding of this issue, Fig. 28-7 shows a table
from the SHARC user manual.  This describes the ways that
multiplication can be carried out for both fixed and floating point
formats.   First, look at how floating point numbers can be multiplied;
there is only one way!  That</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/F_28_7.gif" border="0" alt=""></img></div>

<p>is, Fn = Fx * Fy, where Fn, Fx, and Fy are any of the 16 data registers. 
It could not be any simpler.  In comparison, look at all the possible
commands for fixed point multiplication.  These are the many options
needed to efficiently handle the problems of round-off, scaling, and
format.</p>

<p>In Fig. 28-7, Rn, Rx, and Ry refer to any of the 16 data registers, and
MRF and MRB are 80 bit accumulators.  The vertical lines indicate
<i>options.</i> For instance, the top-left entry in this table means that all the
following are valid commands:  Rn = Rx * Ry, MRF = Rx * Ry, and
MRB = Rx * Ry.  In other words, the value of any two registers can be
multiplied and placed into another register, or into one of the extended
precision accumulators.  This table also shows that the numbers may be
either signed or unsigned (S or U), and may be fractional or integer (F
or I).  The RND and SAT options are ways of controlling rounding and
register overflow.  </p>

<p>There are other details and options in the table, but they are not
important for our present discussion.  The important idea is that the
fixed point programmer must understand <i>dozens</i> of ways to carry out the
very basic task of multiplication.  In contrast, the floating point
programmer can spend his time concentrating on the algorithm.</p>

<p>Given these tradeoffs between fixed and floating point, how do you
choose which to use?  Here are some things to consider.  First, look at
how many bits are used in the ADC and DAC.  In many applications,
12-14 bits per sample is the crossover for using fixed versus floating
point.  For instance, television and other video signals typically use 8 bit
ADC and DAC, and the precision of fixed point is acceptable.  In
comparison, professional audio applications can sample with as high as
20 or 24 bits, and almost certainly need floating point to capture the
large dynamic range. </p>

<p>The next thing to look at is the complexity of the algorithm that will be
run.  If it is relatively simple, think fixed point; if it is more
complicated, think floating point.  For example, FIR filtering and other
operations in the time domain only require a few dozen lines of code,
making them suitable for fixed point. In contrast, frequency domain
algorithms, such as spectral analysis and FFT convolution, are very
detailed and can be much more difficult to program. While they can be
written in fixed point, the development time will be greatly reduced if
floating point is used. </p>

<p>Lastly, think about the money: how important is the cost of the product,
and how important is the cost of the development?  When fixed point is
chosen, the cost of the product will be reduced, but the development cost
will probably be higher due to the more difficult algorithms.  In the
reverse manner, floating point will generally result in a quicker and
cheaper development cycle, but a more expensive final product.   </p>

<p>Figure 28-8 shows some of the major trends in DSPs.  Figure (a)
illustrates the impact that Digital Signal Processors have had on the
<i>embedded</i> market.  These are applications that use a microprocessor to
directly operate and control some larger system, such as a cellular
telephone, microwave oven, or automotive instrument display panel. 
The name "microcontroller" is often used in referring to these devices,
to distinguish them from the microprocessors used in personal
computers.   As shown in (a), about 38% of embedded designers have
already started using DSPs, and another 49% are considering the switch. 
The high throughput and computational power of DSPs often makes
them an ideal choice for embedded designs. </p>

<p>As illustrated in (b), about twice as many engineers currently use fixed
point as use floating point DSPs.  However, this depends greatly on the
application.  Fixed point is more popular in competitive consumer
products where the cost of the electronics must be kept very low.  A
good example of this is cellular telephones.  When you are in
competition to sell millions of your product, a cost difference of only a
few dollars can be the difference between success and failure.  In
comparison, floating point is more common when greater performance
is needed and cost is not important.  For </p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/F_28_8.gif" border="0" alt=""></img></div>

<p>instance, suppose you are designing a medical imaging system, such a
computed tomography scanner.  Only a few  hundred of the model will
ever be sold, at a price of several hundred-thousand dollars each.  For
this application, the cost of the DSP is insignificant, but the performance
is critical.   In spite of the larger number of fixed point DSPs being
used, the floating point market is the fastest growing segment.  As
shown in (c), over one-half of engineers using 16-bits devices plan to
migrate to floating point at some time in the near future.</p>

<p>Before leaving this topic, we should reemphasize that floating point and
fixed point usually use 32 bits and 16 bits, respectively, <i>but not always</i>. 
For instance, the SHARC family can represent numbers in 32-bit fixed
point, a mode that is common in digital audio applications.  This makes
the 2<sup>32</sup> quantization levels spaced uniformly over a relatively small
range, say, between -1 and 1.  In comparison, floating point notation
places the 2<sup>32</sup> quantization levels logarithmically over a huge range,
typically &plusmn;3.4&times;10<sup>38</sup>.  This gives 32-bit fixed point better <i>precision</i>, that
is, the quantization error on any one sample will be lower.   However,
32-bit floating point has a higher <i>dynamic range</i>, meaning there is a
greater difference between the largest number and the smallest number
that can be represented.   </p></div></p>Next Section: <a href="5.htm">C versus Assembly</a>			

		</div>
		<div class="clear"><!-- --></div>
		

	</div>
</div>

<!-- Footer -->

<div id="footer">
	<a href="../index.html">Home</a> | <a href="../pdfbook.htm">The Book by Chapters</a> | <a href="../about.htm">About the Book</a> | <a href="../swsmith.htm">Steven W. Smith</a> | <a href="http://www.dsprelated.com/blogs-1/nf/Steve_Smith.php">Blog</a> | <a href="../contact.htm">Contact</a>
	<br />
	Copyright Â© 1997-2011 by California Technical Publishing
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-1774944-11");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
