	 

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>C versus Assembly</title>
<link href="../new/css/default.css" rel="stylesheet" type="text/css" />

<script type='text/javascript' src='../new/js/jquery-1.5.js'></script>
<script type='text/javascript' src='../new/js/jquery.droppy.js'></script>
<link rel="stylesheet" href="../new/css/droppy.css" type="text/css" />
<script type='text/javascript' src='../new/js/jcc.js'></script>
<script>
$(function(){
	if($.browser.msie){
        if($.browser.version.substr(0,1)!="9"){
            $('#greenBox2').corner({tl:{radius:5}, tr:{radius:5}, bl:{radius:5}, br:{radius:5}, antiAlias:true });
        }
    }else{
        $('#greenBox2').corner({tl:{radius:5}, tr:{radius:5}, bl:{radius:3}, br:{radius:5}, antiAlias:true });
    }
});
</script>

<link rel="stylesheet" href="../new/css/jquery.treeview.css" />
<script src="../new/js/jquery.cookie.js" type="text/javascript"></script>
<script src="../new/js/jquery.treeview.js" type="text/javascript"></script>
<script type="text/javascript" src="../new/js/demo.js"></script>

</head>

<body>


<div id="divPage">
	<div id="wrapper" class="not-logged-in">
		
		<!-- Header -->
		
<div id="header">
			<h1>The Scientist and Engineer's Guide to<br />Digital Signal Processing<br /><span class="txtBlue txt26">By Steven W. Smith, Ph.D.</span></h1>
			<div id="menu">
				<ul id='nav' style="margin-left:10px;"><li><a href="../index.html">Home</a></li><li><a href="../pdfbook.htm" class="selected">The Book by Chapters</a></li><li class="drop"><a href="../about.htm">About the Book</a>					
					<ul>						
						<li><a href="../copyrite.htm">Copyright and permissible use</a></li>							
						<li><a href="../whatdsp.htm">What is DSP?</a></li>
						<li><a href="../eightres.htm">8 good reasons for learning DSP</a></li>
						<li><a href="../reviews.htm">Comments by reviewers</a></li>
						<li><a href="../errata.htm">Errata</a></li>			
						<li><a href="http://www.dspguide.com/ch28/download.htm">Free Software and Teaching Aids</a></li>						
						<li><a href="../editions.htm">Differences Between Editions</a></li>
					</ul>
				  </li><li><a href="../swsmith.htm">Steven W. Smith</a></li><li><a href="http://www.dsprelated.com/blogs-1/nf/Steve_Smith.php">Blog</a></li><li><a href="../contact.htm">Contact</a></li>					
				</ul>
				<script type="text/javascript">$(function() {$("#nav").droppy();});</script>
			</div>
		</div>

		
		<!-- Content -->
		
		<!-- -->		
		<div id="columnLeft">			
			
			<div class="box">
				<h2>Book Search</h2>
				<div id="search">
					<form action="http://www.dspguide.com/search.php" method="post">
						<input type="text" name="searchfor" class="txtField" />
						<input type="image" src="../new/images/btn-go.png" name="Submit" value="Submit" class="button" />
						<div class="clear"><!-- --></div>
					</form>
				</div>
			</div>
		
			
			<div class="box">
				<h2>Download this chapter in PDF format</h2>
				<b><a href="../CH28.PDF">Chapter28.pdf</a></b>
				<br />
				<img src="../new/images/adobe-reader.png" alt="" vspace="5" />
			</div>

			<div class="box">
				<h2>Table of contents</h2>
				<ul id="red" class="treeview-red">	 
					<ul style="border-top:1px solid #aeaeeb;"><li style="border-top:1px solid #aeaeeb;"><a href="../ch1.htm">1: The Breadth and Depth of DSP</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/1.htm">The Roots of DSP</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/2.htm">Telecommunications</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/3.htm">Audio Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/4.htm">Echo Location</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch1/5.htm" style="color:#b4b4e9;">Image Processing</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2.htm">2: Statistics, Probability and Noise</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/1.htm">Signal and Graph Terminology</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/2.htm">Mean and Standard Deviation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/3.htm">Signal vs. Underlying Process</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/4.htm">The Histogram, Pmf and Pdf</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/5.htm" style="color:#b4b4e9;">The Normal Distribution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/6.htm">Digital Noise Generation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch2/7.htm">Precision and Accuracy</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3.htm">3: ADC and DAC</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/1.htm">Quantization</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/2.htm">The Sampling Theorem</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/3.htm">Digital-to-Analog Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/4.htm">Analog Filters for Data Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/5.htm" style="color:#b4b4e9;">Selecting The Antialias Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/6.htm">Multirate Data Conversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch3/7.htm">Single Bit Data Conversion</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4.htm">4: DSP Software</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/1.htm">Computer Numbers</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/2.htm">Fixed Point (Integers)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/3.htm">Floating Point (Real Numbers)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/4.htm">Number Precision</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/5.htm" style="color:#b4b4e9;">Execution Speed: Program Language</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/6.htm">Execution Speed: Hardware</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch4/7.htm">Execution Speed: Programming Tips</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5.htm">5: Linear Systems</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/1.htm">Signals and Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/2.htm">Requirements for Linearity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/3.htm">Static Linearity and Sinusoidal Fidelity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/4.htm">Examples of Linear and Nonlinear Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/5.htm" style="color:#b4b4e9;">Special Properties of Linearity</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/6.htm">Superposition: the Foundation of DSP</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/7.htm">Common Decompositions</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch5/8.htm">Alternatives to Linearity</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6.htm">6: Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/1.htm">The Delta Function and Impulse Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/2.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/3.htm">The Input Side Algorithm</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/4.htm">The Output Side Algorithm</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch6/5.htm" style="color:#b4b4e9;">The Sum of Weighted Inputs</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7.htm">7: Properties of Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/1.htm">Common Impulse Responses</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/2.htm">Mathematical Properties</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/3.htm">Correlation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch7/4.htm">Speed</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8.htm">8: The Discrete Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/1.htm">The Family of Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/2.htm">Notation and Format of the Real DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/3.htm">The Frequency Domain's Independent Variable</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/4.htm">DFT Basis Functions</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/5.htm" style="color:#b4b4e9;">Synthesis, Calculating the Inverse DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/6.htm">Analysis, Calculating the DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/7.htm">Duality</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/8.htm">Polar Notation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch8/9.htm">Polar Nuisances</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9.htm">9: Applications of the DFT</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/1.htm">Spectral Analysis of Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/2.htm">Frequency Response of Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch9/3.htm">Convolution via the Frequency Domain</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10.htm">10: Fourier Transform Properties</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/1.htm">Linearity of the Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/2.htm">Characteristics of the Phase</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/3.htm">Periodic Nature of the DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/4.htm">Compression and Expansion, Multirate methods</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/5.htm" style="color:#b4b4e9;">Multiplying Signals (Amplitude Modulation)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/6.htm">The Discrete Time Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch10/7.htm">Parseval's Relation</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11.htm">11: Fourier Transform Pairs</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/1.htm">Delta Function Pairs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/2.htm">The Sinc Function</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/3.htm">Other Transform Pairs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/4.htm">Gibbs Effect</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch11/5.htm" style="color:#b4b4e9;">Harmonics</a></li><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch11/6.htm">Chirp Signals</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12.htm">12: The Fast Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/1.htm">Real DFT Using the Complex DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/2.htm">How the FFT works</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/3.htm">FFT Programs</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/4.htm">Speed and Precision Comparisons</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch12/5.htm" style="color:#b4b4e9;">Further Speed Increases</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13.htm">13: Continuous Signal Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/1.htm">The Delta Function</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/2.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/3.htm">The Fourier Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch13/4.htm">The Fourier Series</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14.htm">14: Introduction to Digital Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/1.htm">Filter Basics</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/2.htm">How Information is Represented in Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/3.htm">Time Domain Parameters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/4.htm">Frequency Domain Parameters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/5.htm" style="color:#b4b4e9;">High-Pass, Band-Pass and Band-Reject Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch14/6.htm">Filter Classification</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15.htm">15: Moving Average Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/1.htm">Implementation by Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/2.htm">Noise Reduction vs. Step Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/3.htm">Frequency Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/4.htm">Relatives of the Moving Average Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch15/5.htm" style="color:#b4b4e9;">Recursive Implementation</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16.htm">16: Windowed-Sinc Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/1.htm">Strategy of the Windowed-Sinc</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/2.htm">Designing the Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/3.htm">Examples of Windowed-Sinc Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch16/4.htm">Pushing it to the Limit</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17.htm">17: Custom Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/1.htm">Arbitrary Frequency Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/2.htm">Deconvolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch17/3.htm">Optimal Filters</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18.htm">18: FFT Convolution</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/1.htm">The Overlap-Add Method</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/2.htm">FFT Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch18/3.htm">Speed Improvements</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19.htm">19: Recursive Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/1.htm">The Recursive Method</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/2.htm">Single Pole Recursive Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/3.htm">Narrow-band Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/4.htm">Phase Response</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch19/5.htm" style="color:#b4b4e9;">Using Integers</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20.htm">20: Chebyshev Filters</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/1.htm">The Chebyshev and Butterworth Responses</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/2.htm">Designing the Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/3.htm">Step Response Overshoot</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch20/4.htm">Stability</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21.htm">21: Filter Comparison</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/1.htm">Match #1: Analog vs. Digital Filters</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/2.htm">Match #2: Windowed-Sinc vs. Chebyshev</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch21/3.htm">Match #3: Moving Average vs. Single Pole</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22.htm">22: Audio Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/1.htm">Human Hearing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/2.htm">Timbre</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/3.htm">Sound Quality vs. Data Rate</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/4.htm">High Fidelity Audio</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/5.htm" style="color:#b4b4e9;">Companding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/6.htm">Speech Synthesis and Recognition</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch22/7.htm">Nonlinear Audio Processing</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23.htm">23: Image Formation & Display</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/1.htm">Digital Image Structure</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/2.htm">Cameras and Eyes</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/3.htm">Television Video Signals</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/4.htm">Other Image Acquisition and Display</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/5.htm" style="color:#b4b4e9;">Brightness and Contrast Adjustments</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/6.htm">Grayscale Transforms</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch23/7.htm">Warping</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24.htm">24: Linear Image Processing</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/1.htm">Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/2.htm">3x3 Edge Modification</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/3.htm">Convolution by Separability</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/4.htm">Example of a Large PSF: Illumination Flattening</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/5.htm" style="color:#b4b4e9;">Fourier Image Analysis</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/6.htm">FFT Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch24/7.htm">A Closer Look at Image Convolution</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25.htm">25: Special Imaging Techniques</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/1.htm">Spatial Resolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/2.htm">Sample Spacing and Sampling Aperture</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/3.htm">Signal-to-Noise Ratio</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/4.htm">Morphological Image Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch25/5.htm" style="color:#b4b4e9;">Computed Tomography</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26.htm">26: Neural Networks (and more!)</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/1.htm">Target Detection</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/2.htm">Neural Network Architecture</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/3.htm">Why Does it Work?</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/4.htm">Training the Neural Network</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/5.htm" style="color:#b4b4e9;">Evaluating the Results</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch26/6.htm">Recursive Filter Design</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27.htm">27: Data Compression</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/1.htm">Data Compression Strategies</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/2.htm">Run-Length Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/3.htm">Huffman Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/4.htm">Delta Encoding</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/5.htm" style="color:#b4b4e9;">LZW Compression</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/6.htm">JPEG (Transform Compression)</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch27/7.htm">MPEG</a></li></ul></li><li class="open" style="border-top:1px solid #aeaeeb;"><a href="../ch28.htm" style="color:#b4b4e9;">28: Digital Signal Processors</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="1.htm">How DSPs are Different from Other Microprocessors</a></li><li style="border-top:1px solid #aeaeeb;"><a href="2.htm">Circular Buffering</a></li><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch28/3.htm">Architecture of the Digital Signal Processor</a></li><li style="border-top:1px solid #aeaeeb;"><a href="4.htm">Fixed versus Floating Point</a></li><li style="border-top:1px solid #aeaeeb;"><a href="5.htm" style="color:#b4b4e9;">C versus Assembly</a></li><li style="border-top:1px solid #aeaeeb;"><a href="6.htm">How Fast are DSPs?</a></li><li style="border-top:1px solid #aeaeeb;"><a href="7.htm">The Digital Signal Processor Market</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29.htm">29: Getting Started with DSPs</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="http://www.dspguide.com/ch29/1.htm">The ADSP-2106x family</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/2.htm">The SHARC EZ-KIT Lite</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/3.htm">Design Example: An FIR Audio Filter</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/4.htm">Analog Measurements on a DSP System</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/5.htm" style="color:#b4b4e9;">Another Look at Fixed versus Floating Point</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch29/6.htm">Advanced Software Tools</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30.htm">30: Complex Numbers</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/1.htm">The Complex Number System</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/2.htm">Polar Notation</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/3.htm">Using Complex Numbers by Substitution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/4.htm">Complex Representation of Sinusoids</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/5.htm" style="color:#b4b4e9;">Complex Representation of Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch30/6.htm">Electrical Circuit Analysis</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31.htm">31: The Complex Fourier Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/1.htm">The Real DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/2.htm">Mathematical Equivalence</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/3.htm">The Complex DFT</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/4.htm">The Family of Fourier Transforms</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch31/5.htm" style="color:#b4b4e9;">Why the Complex Fourier Transform is Used</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32.htm">32: The Laplace Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/1.htm">The Nature of the s-Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/2.htm">Strategy of the Laplace Transform</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/3.htm">Analysis of Electric Circuits</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/4.htm">The Importance of Poles and Zeros</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch32/5.htm" style="color:#b4b4e9;">Filter Design in the s-Domain</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33.htm">33: The z-Transform</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/1.htm">The Nature of the z-Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/2.htm">Analysis of Recursive Systems</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/3.htm">Cascade and Parallel Stages</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/4.htm">Spectral Inversion</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/5.htm" style="color:#b4b4e9;">Gain Changes</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/6.htm">Chebyshev-Butterworth Filter Design</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch33/7.htm">The Best and Worst of DSP</a></li></ul></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34.htm">34: Explaining Benford's Law</a><ul><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/1.htm">Frank Benford's Discovery</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/2.htm">Homomorphic Processing</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/3.htm">The Ones Scaling Test</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/4.htm">Writing Benford's Law as a Convolution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/5.htm" style="color:#b4b4e9;">Solving in the Frequency Domain</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/6.htm">Solving Mystery #1</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/7.htm">Solving Mystery #2</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/8.htm">More on Following Benford's law</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/9.htm">Analysis of the Log-Normal Distribution</a></li><li style="border-top:1px solid #aeaeeb;"><a href="../ch34/10.htm">The Power of Signal Processing</a></li></ul></li>
					</ul>
				</ul>			
			</div>

			<div class="box">
				<h2>How to order your own hardcover copy</h2>
				Wouldn't you rather have a bound book instead of 640 loose pages?<br />
				Your laser printer will thank you!<br />
				<b>Order from <a href="http://www.amazon.com/Scientist-Engineers-Digital-Signal-Processing/dp/0966017633/ref=pd_bxgy_b_img_a">Amazon.com</a>.</b>
			</div>

		
			
		</div>	

		<!-- -->		
		<div id="columnRight">	
		
			<div id="adbox">
				
			
			</div>	 
			
<div class="breadcrumbs"><a href="../ch28.htm">Chapter 28 - Digital Signal Processors</a> / C versus Assembly</div><h2>Chapter 28: Digital Signal Processors</h2><div class="subTitle">C versus Assembly</div><p><div style="text-align: justify"><p>DSPs are programmed in the same languages as other scientific and
engineering applications, usually <i>assembly</i> or <i>C</i>. Programs written in
assembly can execute faster, while programs written in C are easier to
develop and maintain.  In traditional applications, such as programs run
on personal computers and mainframes, C is almost always the first
choice.  If assembly is used at all, it is restricted to short subroutines
that must run with the utmost speed.  This is shown graphically in Fig.
28-9a; for every traditional programmer that works in assembly, there
are approximately <i>ten</i> that use C.</p>

<p>However, DSP programs are different from traditional software tasks in
two important respects.  First, the programs are usually much shorter,
say, one-hundred lines versus ten-thousand lines.  Second, the execution
speed is often a critical part of the application.  After all, that's why
someone uses a DSP in the first place, for its blinding speed.   These
two factors motivate many software engineers to switch from C to
assembly for programming Digital Signal Processors.   This is illustrated
in (b); nearly as many DSP programmers use assembly as use C. </p>

<p>Figure (c) takes this further by looking at the revenue produced by DSP
products.  For every dollar made with a DSP programmed in C, two
dollars are made with a DSP programmed in assembly.  The reason for
this is simple; money is made by outperforming the competition.  From
a pure performance standpoint, such as execution speed and
manufacturing cost, assembly almost always has the advantage over C. 
For instance, C code usually requires a larger memory than assembly,
resulting in more expensive hardware.  However, the DSP market is
continually changing.  As the market grows, manufacturers will respond
by designing DSPs that are <i>optimized</i> for programming in C.  For
instance, C is much more efficient when there is a large, general purpose
register set and a unified memory space.  These future improvements
will minimize the difference in execution time between C and assembly,
and allow C to be used in more applications. </p>

<p>To better understand this decision between C and assembly, let's
look at a typical DSP task programmed in each language.  The
example we will use is the calculation of the <i>dot product</i> of the two
arrays, <i>x</i>[ ] and <i>y</i>[ ].  This is a simple mathematical operation, we
multiply each coefficient in one</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/F_28_9.gif" border="0" alt=""></img></div>

<p>array by the corresponding coefficient in the other array, and sum the
products, i.e. <i>x</i>[0]&times;<i>y</i>[0] + <i>x</i>[1]×<i>y</i>[1] + <i>x</i>[2]×<i>y</i>[2] + &hellip;.  This should look very
familiar; it is the fundamental operation in an FIR filter.  That is, each
sample in the output signal is found by multiplying stored samples from
the input signal (in one array) by the filter coefficients (in the other
array), and summing the products. </p>

<p>Table 28-2 shows how the dot product is calculated in a C program.  In
lines 001-004 we define the two arrays, <i>x</i>[ ] and <i>y</i>[ ], to be 20 elements
long.  We also define <i>result</i>, the variable that holds the calculated dot</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/T_28_2.gif" border="0" alt=""></img></div>

<p>product at the completion of the program.  Line 011 controls the 20
loops needed for the calculation, using the variable <i>n</i> as a loop counter. 
The only statement within the loop is line 012, which multiplies the
corresponding coefficients from the two arrays, and adds the product to
the accumulator variable, <i>s</i>.  (If you are not familiar with C, the
statement: <i>s</i> += <i>x</i>[<i>n</i>] * <i>y</i>[<i>n</i>] means the same as:  <i>s</i> = <i>s</i> + <i>x</i>[<i>n</i>] * <i>y</i>[<i>n</i>]).  After
the loop, the value in the accumulator, <i>s</i>,  is transferred to the output
variable, <i>result</i>, in line 013.</p>

<p>A key advantage of using a high-level language (such as C, Fortran, or
Basic) is that the programmer does not need to understand the
architecture of the microprocessor being used; knowledge of the
architecture is left to the compiler.  For instance, this short C program
uses several variables: <i>n</i>, <i>s</i>, <i>result</i>, plus the arrays: <i>x</i>[ ] and <i>y</i>[ ].  All of
these variables must be assigned a "home" in hardware to keep track of
their value.  Depending on the microprocessor, these storage locations
can be the general purpose data registers, locations in the main memory,
or special registers dedicated to particular functions.  However, the
person writing a high-level program knows little or nothing about this
memory management; this task has been delegated to the software
engineer who wrote the compiler.  The problem is, these two people
have never met; they only communicate through a set of predefined
rules.  High-level languages are easier than assembly because you give
half the work to someone else.  However, they are less efficient because
you aren't quite sure how the delegated work is being carried out. </p>

<p>In comparison, Table 28-3 shows the dot product program written in
assembly for the SHARC DSP.  The assembly language for the Analog
Devices DSPs (both their 16 bit fixed-point and 32 bit SHARC devices)
are known for their simple algebraic-like syntax. While we won't go
through all the details, here is the general operation.  Notice that
<i>everything</i> relates to hardware; there are no abstract variables in this
code, only data registers and memory locations.    </p>

<p>Each semicolon represents a clock cycle.  The arrays <i>x</i>[ ] and <i>y</i>[ ] are
held in circular buffers in the main memory.  In lines 001 and 002,
registers i4</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/T_28_3.gif" border="0" alt=""></img></div>

<div style="text-align: center; margin: 20px;"><img src="../graphics/T_28_4.gif" border="0" alt=""></img></div>

<p>and i12 are pointed to the starting locations of these arrays.  Next, we
execute 20 loop cycles, as controlled by line 004.  The format for this
statement takes advantage of the SHARC DSP's <i>zero-overhead looping</i>
capability.  In other words, all of the variables needed to control the
loop are held in dedicated hardware registers that operate in parallel
with the other operations going on inside the microprocessor.  In this
case, the register: <i>lcntr</i> (loop counter) is loaded with an initial value of
20, and decrements each time the loop is executed.  The loop is
terminated when <i>lcntr</i> reaches a value of zero (indicated by the
statement: <i>lce</i>, for "loop counter expired").  The loop encompasses lines
004 to 008, as controlled by the statement (pc,4). That is, the loop ends
four lines after the current program counter.</p>

<p>Inside the loop, line 005 loads the value from <i>x</i>[ ] into data register f2,
while line 006 loads the value from <i>y</i>[ ] into data register f4.  The
symbols "dm" and "pm" indicate that the values are fetched over the
"data memory" bus and "program memory" bus, respectively.  The
variables: i4, m6, i12, and m14 are registers in the data address
generators that manage the circular buffers holding <i>x</i>[ ] and <i>y</i>[ ].  The
two values in f2 and f4 are multiplied in line 007, and the product stored
in data register f8.  In line 008, the product in f8 is added to the
accumulator, data register f12.  After the loop is completed, the
accumulator in f12 is transferred to memory.  </p>

<p>This program correctly calculates the dot product, but it does not take
advantage of the SHARC highly parallel architecture.  Table 28-4 shows
this program rewritten in a highly optimized form, with many operations
being carried out in parallel.  First notice that line 007 only executes 18
loops, rather than 20.  Also notice that this loop only contains a single
line (008), but that this line contains multiple instructions.  The strategy
is to make the loop as efficient as possible, in this case, a single line
that can be executed in a single clock cycle.  To do this, we need to have
a small amount of code to "prime" the registers on the first loop (lines
004 and 005), and another small section of code to finish the last loop
(lines 010 and 011).</p>

<p>To understand how this works, study line 008, the only statement inside
the loop.  In this single statement, <i>four</i> operations are being carried out
in parallel: (1) the value for <i>x</i>[ ] is moved from a circular buffer in
program memory and placed in f2; (2) the value for <i>y</i>[ ] is being moved
from a circular buffer in data memory and placed in f4; (3) the previous
values of f2 and f4 are multiplied and placed in f8;  and (4) the previous
value in f8 is added to the accumulator in f12.   </p>

<p>For example, the fifth time that line 008 is executed, <i>x</i>[7] and <i>y</i>[7] are
fetched from memory and stored in f2 and f4.  At the same time, the
values for <i>x</i>[6] and <i>y</i>[6] (that were in f2 and f4 at the start of this cycle)
are multiplied and placed in f8.  In addition, the value of <i>x</i>[5] &times; <i>y</i>[5] (that
was in f8 at the start of this cycle) is added to the value of f12.  </p>

<p>Let's compare the number of clock cycles required by the unoptimized
and the optimized programs.  Keep in mind that there are 20 loops, with
four actions being required in each loop.  The unoptimized program
requires 80 clock cycles to carry out the actions within the loops, plus
5 clock cycles of overhead, for a total of 85 clock cycles.  In
comparison, the optimized program conducts 18 loops in 18 clock
cycles, but requires 11 clock cycles of overhead to prime the registers
and complete the last loop.  This results in a total execution time of 29
clock cycles, or about three times faster than the brute force method.</p>

<p>Here is the big question:  How fast does the C program execute relative
to the assembly code?  When the program in Table 28-2 is compiled,
does the executable code resemble our <i>efficient</i> or <i>inefficient</i> assembly
example?  The answer is that the compiler generates the <i>efficient</i> code. 
However, it is important to realize that the dot product is a very simple
example.  The compiler has a much more difficult time producing
optimized code when the program becomes more complicated, such as
multiple nested loops and erratic jumps to subroutines.  If you are doing
something straightforward, expect the compiler to provide you a nearly
optimal solution.  If you are doing something strange or complicated,
expect that an assembly program will execute significantly faster than
one written in C.  In the worst case, think a factor of 2-3.  As previously
mentioned, the efficiency of C versus assembly depends greatly on the
particular DSP being used.  Floating point architectures can generally be
programmed more efficiently than fixed-point devices when using high-level languages such as C.  Of course, the proper software tools are
important for this, such as a debugger with profiling features that help
you understand how long different code segments take to execute. </p>

<p>There is also a way you can get the best of both worlds: write the
program in C, but use assembly for the critical sections that must
execute quickly. This is one reason that C is so popular in science and
engineering.  It operates as a high-level language, but also allows you
to directly manipulate</p>

<div style="text-align: center; margin: 20px;"><img src="../graphics/F_28_10.gif" border="0" alt=""></img></div>

<p>the hardware if you so desire.  Even if you intend to program only in C,
you will probably need some knowledge of the architecture of the DSP
and the assembly instruction set.   For instance, look back at lines 002
and 003 in Table 28-2, the dot product program in C.  The "dm" means
that <i>x</i>[ ] is to be stored in data memory, while the "pm" indicates that <i>y</i>[ ]
will reside in program memory.  Even though the program is written in
a high level language, a basic knowledge of the hardware is still
required to get the best performance from the device.</p>

<p>Which language is best for <i>your</i> application? It depends on what is more
important to you.  If you need flexibility and fast development, choose
C.  On the other hand, use assembly if you need the best possible
performance.  As illustrated in Fig. 28-10, this is a tradeoff you are
forced to make.  Here are some things you should consider. </p>

<ul type="square">
	<li>How complicated is the program?  If it is large and intricate, you
will probably want to use C.  If it is small and simple, assembly
may be a good choice.</li>
	<li>Are you pushing the maximum speed of the DSP?  If so, assembly
will give you the last drop of performance from the device.  For less
demanding applications, assembly has little advantage, and you
should consider using C.</li>
	<li>How many programmers will be working together?  If the project is
large enough for more than one programmer, lean toward C and use
in-line assembly only for time critical segments.</li>
	<li>Which is more important, <i>product cost</i> or <i>development cost</i>?  If it is
product cost, choose assembly; if it is development cost, choose C.</li>
	<li>What is your background? If you are experienced in assembly (on
other microprocessors), choose assembly for your DSP.  If your
previous work is in C, choose C for your DSP.</li>
	<li>What does the DSP's manufacturer suggest you use?</li>				
</ul>

<p>This last item is very important.  Suppose you ask a DSP manufacturer
which language to use, and they tell you: <i>"Either C or assembly can be
used, but we recommend C."</i>  You had better take their advice!  What they
are really saying is: <i>"Our DSP is so difficult to program in assembly that
you will need 6 months of training to use it."</i>  On the other hand, some
DSPs are easy to program in assembly.  For instance, the Analog Devices
products are in this category. Just ask their engineers; they are very proud
of this. </p>

<p>One of the best ways to make decisions about DSP products and
software is to speak with engineers who have used them.  Ask the
manufacturers for references of companies using their products, or
search the web for people you can e-mail.  Don't be shy; engineers love
to give their opinions on products they have used.  They will be flattered
that you asked.</p></div></p>Next Section: <a href="6.htm">How Fast are DSPs?</a>			

		</div>
		<div class="clear"><!-- --></div>
		

	</div>
</div>

<!-- Footer -->

<div id="footer">
	<a href="../index.html">Home</a> | <a href="../pdfbook.htm">The Book by Chapters</a> | <a href="../about.htm">About the Book</a> | <a href="../swsmith.htm">Steven W. Smith</a> | <a href="http://www.dsprelated.com/blogs-1/nf/Steve_Smith.php">Blog</a> | <a href="../contact.htm">Contact</a>
	<br />
	Copyright Â© 1997-2011 by California Technical Publishing
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-1774944-11");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
